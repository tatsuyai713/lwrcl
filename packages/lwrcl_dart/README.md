# lwrcl_dart

Dart FFI bindings for lwrcl (LightWeight rclcpp compatible library).

## Build the native library

Build and install lwrcl (this now also builds `liblwrcl_ffi`):

```bash
cd lwrcl
./build_lwrcl.sh install
```

The shared library is installed into `/opt/fast-dds-libs/lib` by default.

## Run the Dart example

Make sure the shared library is discoverable:

```bash
export LD_LIBRARY_PATH=/opt/fast-dds-libs/lib:$LD_LIBRARY_PATH
```

Then run:

```bash
dart run example/main.dart
```

## Flutter usage

This package is Flutter-friendly because it uses `dart:ffi`. For Flutter desktop (Linux),
ensure `liblwrcl_ffi.so` is discoverable by the app (for example, by copying it into
`build/linux/x64/debug/bundle/lib` or setting `LD_LIBRARY_PATH` when launching).

**Android (Flutter)**

**Prerequisites**
- Android NDK (set `ANDROID_NDK_HOME`).
- CMake and a C++ toolchain on the host machine.
- Initialize submodules: `git submodule update --init --recursive`.
- Decide target ABI and API level (example: `ANDROID_ABI=arm64-v8a`, `ANDROID_API=31`).
- Use one shared install prefix for all Android builds (example: `ANDROID_PREFIX=$PWD/android/arm64-v8a`).

**Steps**
1. Build Fast DDS and its dependencies for Android into the shared prefix.

```bash
ANDROID_NDK_HOME=/path/to/android-ndk \
ANDROID_ABI=arm64-v8a \
ANDROID_API=31 \
ANDROID_PREFIX=$PWD/lwrcl/android/arm64-v8a \
FAST_DDS_PREFIX=$PWD/lwrcl/android/arm64-v8a \
./scripts/install_fast_dds_android.sh
```

2. Build support libraries (yaml-cpp) for Android into the same prefix.

```bash
cd lwrcl
ANDROID_NDK_HOME=/path/to/android-ndk \
ANDROID_ABI=arm64-v8a \
ANDROID_API=31 \
ANDROID_PREFIX=$PWD/android/arm64-v8a \
FAST_DDS_PREFIX=$PWD/android/arm64-v8a \
./build_libraries_android.sh install
```

3. Build lwrcl data types and lwrcl itself for the same prefix.

```bash
ANDROID_NDK_HOME=/path/to/android-ndk \
ANDROID_ABI=arm64-v8a \
ANDROID_API=31 \
ANDROID_PREFIX=$PWD/android/arm64-v8a \
FAST_DDS_PREFIX=$PWD/android/arm64-v8a \
./build_data_types_android.sh install

ANDROID_NDK_HOME=/path/to/android-ndk \
ANDROID_ABI=arm64-v8a \
ANDROID_API=31 \
ANDROID_PREFIX=$PWD/android/arm64-v8a \
FAST_DDS_PREFIX=$PWD/android/arm64-v8a \
./build_lwrcl_android.sh install
```

4. Copy the Android `.so` files into your Flutter app.

```bash
FLUTTER_APP_DIR=/path/to/your/app \
ANDROID_ABI=arm64-v8a \
ANDROID_API=31 \
ANDROID_NDK_HOME=/path/to/android-ndk \
./scripts/copy_android_jni_libs.sh
```

5. Set `minSdkVersion` and ABI filters in `android/app/build.gradle`.

```gradle
android {
  defaultConfig {
    minSdkVersion 31
    ndk {
      abiFilters 'arm64-v8a'
    }
  }
}
```

6. Run the Flutter app.

```bash
flutter run
```

**Notes**
- Repeat the build steps per ABI if you need multiple ABIs.
- Ensure the following libraries are in `android/app/src/main/jniLibs/<ABI>/`: `liblwrcl_ffi.so`, `liblwrcl.so`, `libfastrtps.so`, `libfastcdr.so`, `libfoonathan_memory.so`, `libtinyxml2.so`, `libyaml-cpp.so`, and `libc++_shared.so`.
- Dart loads `liblwrcl_ffi.so` automatically. To override the path, set `LWRCL_FFI_LIB`.
- On aarch64 hosts the NDK host toolchain may be missing. In that case, use `scripts/build_ndk_aarch64_linux.sh` (automates the SnowNF/ndk-aarch64-linux steps) to build a host NDK and run it with `NDK_ROOT` set.

## Usage (C++-like API)

Message classes are auto-generated from IDL. You can publish/subscribe without manually
serializing in Dart.

```dart
final node = Node.create('dart_node');
final pub = node.createPublisher<StdMsgsString>(StdMsgsString.type, 'chatter');
final sub = node.createSubscription<StdMsgsString>(
  StdMsgsString.type,
  () => StdMsgsString(),
  'chatter',
);

final msg = StdMsgsString();
msg.data = 'hello';
pub.publish(msg);
msg.dispose();

final received = sub.take();
if (received != null) {
  print(received.data);
  received.dispose();
}
```

### Notes

- Generated message classes live in `lib/src/generated/messages.dart` (auto-generated by `scripts/generate_lwrcl_ffi.py` during `./build_lwrcl.sh install`, and not tracked by git). If it is missing, run the build or the generator script to recreate it.
- Call `node.spinSome()` periodically to drain callback queues.
